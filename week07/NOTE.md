### 类属性和对象属性

##### 区别

1. 类属性字段在内存中只保存一份
2. 对象属性在每个对象中都保存一份

### 类的属性作用域

- \_name 人为约定不可修改
- \_\_name 私有属性
- \_\_name\_\_ 魔术方法

> 私有属性是可以访问到的，Python 通过改名机制隐藏了变量名称

### 类的方法描述器

##### 三种方法

> 三种方法在内存中都归属于类

- 普通方法：至少一个 self 参数，表示该方法的对象
- 类方法：至少一个 cls 参数，表示该方法的类
- 静态方法：由类调用，无参数

> 类方法可以通过实例调用，实例调用方法的逻辑是先找实例的方法，再找实例所在类中的方法

##### 类方法

###### 定义

类方法其实是构造函数，类当中有且只有一个构造函数 \_\_new\_\_()，不能够满足需求

###### 类方法的两大使用场景

- 定义到父类中，当使用子类，子类需要根据自己的变量名发生变化的时候可以引用到父类的 classmethod
- 当函数去调用类，并且返回我们的类的时候

##### 静态方法

### 特殊属性和方法

##### \_\_init()\_\_

- \_\_init\_\_() 方法所做的工作是在类的对象创建好之后进行变量的初始化
- \_\_init\_\_() 方法不需要显式返回，默认为 None，否则会在运行时抛出 TypeError

##### self

- self 表示实例对象本身
- self 不是 Python 的关键字(cls 也不是)，可以将 self 替换成任何你喜欢的名称，如 this、obj 等，实际效果和 self 是一样的(不推荐)
- 在方法声明时，需要定义 self 作为第一个参数，调用方法的时候不用传入 self

### 描述器高级应用

##### \_\_getattribute\_\_()

拦截获取属性，并对其进行扩展

##### \_\_getattr\_\_()

获取到不存在的属性的时候可以进行处理

##### 异同

- 都可以对==实例==属性进行获取拦截
- \_\_getattr\_\_() 适用于未定义的属性
- \_\_getattribute\_\_() 对所有属性的访问都会调用该方法

##### 注意事项

- 无论是属性存在或者不存在，getattribute 都会去调用，对性能会有所损耗
- 在使用 getattr 的时候 \_\_dict\_\_ 里面依然没有这个属性，hasattr 可能为 True

### 属性描述符

描述器：实现特定协议（描述符）的类

property 类需要实现 \_\_get**、\_\_set**、\_\_delete\_\_ 方法

property 的优点

1. 代码更简洁，可读性、可维护性更强
2. 更好的管理属性的访问
3. 控制属性访问权限，提高数据安全性

### 继承

##### object 和 type 的关系

- object 和 type 都属于 type 类 (class 'type')
- type 类由 type 元类自身创建的。object 类是由元类 type 创建
- object 的父类为空，没有继承任何类
- type 的父类为 object 类 (class 'object')

##### 单一继承

##### 多重继承

多重继承的顺序问题

1. subclass.mro()
2. 有向无环图（DAG）

##### 钻石继承

##### 继承机制 MRO

##### MRO 的 C3 算法

### SOLID 设计原则

- 单一责任原则
- 开放封闭原则
- 里氏替换原则
- 依赖倒置原则
- 接口分离原则

### 设计模式

##### 单例模式

\_\_init** 和 \_\_new** 的区别

- \_\_new\_\_ 是实例创建之前被调用，返回该实例对象，是静态方法
- \_\_init\_\_ 是实例对象创建完成后被调用，是实例方法
- \_\_new** 先被调用，\_\_init** 后被调用
- \_\_new** 的返回值(实例)将传递给 \_\_init** 方法的第一个参数，\_\_init\_\_ 给这个
  实例设置相关参数

创建单实例的方法

1. 装饰器的方式（没有多线程的推荐方式）
2. \_\_new\_\_ 的方式（线程安全的）
3. import 方式（最简单、最安全）

##### 工厂模式

### 元类

元类是关于类的类，是类的模板

元类是用来控制如何创建类的，正如类是创建对象的模板一样

元类的实例为类，正如类的实例为对象

创建元类的两种方法

1. class
2. type

> type( 类名, 父类的元组(可以为空), 类的成员(字典) )

```
# 使用type元类创建类
def hi():
    print('Hi metaclass')

# type的三个参数:类名、父类的元组、类的成员
Foo = type('Foo',(),{'say_hi':hi})
foo = Foo
foo.say_hi()
# 元类type首先是一个类，所以比类工厂的方法更灵活多变，可以自由创建子类来扩展元类的能力
```

```
def pop_value(self,dict_value):
    for key in self.keys():
        if self.__getitem__(key) == dict_value:
            self.pop(key)
            break

# 元类要求,必须继承自type
class DelValue(type):
    # 元类要求，必须实现new方法
    def __new__(cls,name,bases,attrs):
        attrs['pop_value'] = pop_value
        return type.__new__(cls,name,bases,attrs)

class DelDictValue(dict,metaclass=DelValue):
    # python2的用法，在python3不支持
    # __metaclass__ = DelValue
    pass

d = DelDictValue()
d['a']='A'
d['b']='B'
d['c']='C'
d.pop_value('C')
for k,v in d.items():
    print(k,v)
```

### mixin 模式

在程序运行过程中，重定义类的继承，即动态继承

好处

1. 可以在不修改任何源代码的情况下，对已有类进行扩展
2. 进行组件的划分
